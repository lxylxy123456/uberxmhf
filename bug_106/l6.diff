diff --git a/hypapps/trustvisor/src/include/tv_log.h b/hypapps/trustvisor/src/include/tv_log.h
index 95011e971..9d2f757f6 100644
--- a/hypapps/trustvisor/src/include/tv_log.h
+++ b/hypapps/trustvisor/src/include/tv_log.h
@@ -48,7 +48,7 @@
 #define TV_LOG_H
 
 #ifndef EU_LOG_LVL
-#define EU_LOG_LVL EU_WARN
+#define EU_LOG_LVL EU_TRACE
 #endif
 
 #ifndef EU_LOG_PREFIX
diff --git a/xmhf/src/libbaremetal/libxmhfutil/include/eulog.h b/xmhf/src/libbaremetal/libxmhfutil/include/eulog.h
index 8416979b4..cdff631e3 100644
--- a/xmhf/src/libbaremetal/libxmhfutil/include/eulog.h
+++ b/xmhf/src/libbaremetal/libxmhfutil/include/eulog.h
@@ -57,7 +57,7 @@
 #endif
 
 #ifndef EU_LOG_LVL
-#define EU_LOG_LVL EU_WARN
+#define EU_LOG_LVL EU_TRACE
 #endif
 
 #ifndef EU_LOG_PRINTLN
diff --git a/xmhf/src/xmhf-core/include/xmhf-debug-event-logger-fields.h b/xmhf/src/xmhf-core/include/xmhf-debug-event-logger-fields.h
index 013a263bb..0d2023f41 100644
--- a/xmhf/src/xmhf-core/include/xmhf-debug-event-logger-fields.h
+++ b/xmhf/src/xmhf-core/include/xmhf-debug-event-logger-fields.h
@@ -63,9 +63,9 @@
  * key_fmt: format string to print the key
  */
 
-DEFINE_EVENT_FIELD(vmexit_cpuid, u32, "%d", 4, u16, u32, "0x%08x")
-DEFINE_EVENT_FIELD(vmexit_rdmsr, u32, "%d", 4, u16, u32, "0x%08x")
-DEFINE_EVENT_FIELD(vmexit_wrmsr, u32, "%d", 4, u16, u32, "0x%08x")
+DEFINE_EVENT_FIELD(vmexit_cpuid, u32, "%d", 1, u16, u32, "0x%08x")
+DEFINE_EVENT_FIELD(vmexit_rdmsr, u32, "%d", 1, u16, u32, "0x%08x")
+DEFINE_EVENT_FIELD(vmexit_wrmsr, u32, "%d", 1, u16, u32, "0x%08x")
 DEFINE_EVENT_FIELD(vmexit_xcph, u32, "%d", 4, u16, u8, "0x%02x")
 DEFINE_EVENT_FIELD(vmexit_other, u32, "%d", 4, u16, u32, "%d")
 DEFINE_EVENT_FIELD(inject_nmi, u32, "%d", 1, u16, u8, "%d")
diff --git a/xmhf/src/xmhf-core/xmhf-runtime/xmhf-nested/arch/x86/vmx/nested-x86vmx-handler2.c b/xmhf/src/xmhf-core/xmhf-runtime/xmhf-nested/arch/x86/vmx/nested-x86vmx-handler2.c
index ff30046d8..d8cb87a2c 100644
--- a/xmhf/src/xmhf-core/xmhf-runtime/xmhf-nested/arch/x86/vmx/nested-x86vmx-handler2.c
+++ b/xmhf/src/xmhf-core/xmhf-runtime/xmhf-nested/arch/x86/vmx/nested-x86vmx-handler2.c
@@ -876,6 +876,7 @@ static u32 handle_vmexit20_vmcall(VCPU * vcpu, struct regs *r)
 		return NESTED_VMEXIT_HANDLE_201;
 	}
 	/* Quiesce, invoke hypapp */
+	//xmhf_nested_arch_x86vmx_vmread_all(vcpu, ":VMCALL:");
 	xmhf_smpguest_arch_x86vmx_quiesce(vcpu);
 	if (xmhf_app_handlehypercall(vcpu, r) != APP_SUCCESS) {
 		printf("CPU(0x%02x): error(halt), unhandled L2 hypercall 0x%08x!\n",
@@ -933,6 +934,7 @@ static void handle_vmexit20_forward(VCPU * vcpu, vmcs12_info_t * vmcs12_info,
 		 * easier. The correct behavior should be injecting the VMEXIT to
 		 * guest hypervisor.
 		 */
+		xmhf_nested_arch_x86vmx_vmread_all(vcpu, ":VMFAIL:");
 		HALT_ON_ERRORCOND(0 && "Debug: guest hypervisor VM-entry failure");
 	}
 
@@ -994,6 +996,41 @@ static void handle_vmexit20_forward(VCPU * vcpu, vmcs12_info_t * vmcs12_info,
 	}
 
 	/* Logging */
+	switch (vmcs12_info->vmcs12_value.info_vmexit_reason) {
+	case 2:
+		printf("Unexpected VMEXIT201: %d\n", vmcs12_info->vmcs12_value.info_vmexit_reason);
+		HALT_ON_ERRORCOND(0);
+		break;
+	case 0: /* fallthrough */
+	case 1: /* fallthrough */
+	case 7: /* fallthrough */
+	case 10: /* fallthrough */
+	case 12: /* fallthrough */
+	case 18: /* fallthrough */
+	case 28: /* fallthrough */
+	case 29: /* fallthrough */
+	case 30: /* fallthrough */
+	case 31: /* fallthrough */
+	case 32: /* fallthrough */
+	case 43: /* fallthrough */
+	case 44: /* fallthrough */
+	case 46: /* fallthrough */
+	case 47: /* fallthrough */
+
+	// Below are Linux
+	case 40: /* fallthrough */
+	case 48: /* fallthrough */
+	case 49: /* fallthrough */
+	case 52: /* fallthrough */
+	case 54: /* fallthrough */
+	// Above are Linux
+
+	case 55:
+		break;
+	default:
+		printf("Unknown 201: %d\n", vmcs12_info->vmcs12_value.info_vmexit_reason);
+		break;
+	}
 #ifdef __DEBUG_EVENT_LOGGER__
 	xmhf_dbg_log_event(vcpu, 1, XMHF_DBG_EVENTLOG_vmexit_201,
 					   &vmcs12_info->vmcs12_value.info_vmexit_reason);
@@ -1065,6 +1102,9 @@ void xmhf_nested_arch_x86vmx_handle_vmexit(VCPU * vcpu, struct regs *r)
 			}
 		}
 		break;
+	case 2:
+		xmhf_nested_arch_x86vmx_vmread_all(vcpu, ":3FAULT:");
+		break;
 	case VMX_VMEXIT_NMI_WINDOW:
 		handle_behavior = handle_vmexit20_nmi_window(vcpu, vmcs12_info);
 		break;
